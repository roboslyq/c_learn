# 1、this file does not belong to any project target, code insight features might not work
> 1、最直观的新建文件的文本编辑页面上方有： 
  This file does not belong to any project target, code insight features might not work properly 
  警告提示。 
  2、左边目录树中，新建文件夹和其中的新建文件都是灰色的。 
  3、而src文件夹和其中的文件都是彩色的。
  原因可能就是没有关联新建的文件夹。
  解决方案： 
  右键点击你新建的文件夹，选择Mark Directotry as，然后选择Project Sources and Headers： 

# 2、编译失败   undefined reference to `max'

修改CMakeLists.txt

```properties
#头文件引用路径：
include_directories(function pthread)

#如果有子CMakeFile文件
#add_subdirectory(function)

#将function/function.c pthread/thread.c组合到变量SOURCE_TMP
set(SOURCE_TMP function/function.c pthread/thread.c)

#控制多个可执行文件，后面${SOURCE_TMP}表示当前main.c中会引入这些文件
add_executable(main main.c ${SOURCE_TMP})
```



# 3、TypeDef使用



C 语言提供了 **typedef** 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 **BYTE**：

```c
typedef unsigned char BYTE;
```

在这个类型定义之后，标识符 BYTE 可作为类型 **unsigned char** 的缩写，例如：

```c
BYTE  b1, b2;
```

按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写，但您也可以使用小写字母，如下：

```c
typedef unsigned char byte;
```

您也可以使用 **typedef** 来为用户自定义的数据类型取一个新的名字。例如，您可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量，如下：

```c
#include <stdio.h>
#include <string.h>
 
typedef struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} Book;
 
int main( )
{
   Book book;
 
   strcpy( book.title, "C 教程");
   strcpy( book.author, "Runoob"); 
   strcpy( book.subject, "编程语言");
   book.book_id = 12345;
 
   printf( "书标题 : %s\n", book.title);
   printf( "书作者 : %s\n", book.author);
   printf( "书类目 : %s\n", book.subject);
   printf( "书 ID : %d\n", book.book_id);
 
   return 0;
}
```



当上面的代码被编译和执行时，它会产生下列结果：

> 书标题 : C 教程
> 书作者 : Runoob
> 书类目 : 编程语言
> 书 ID : 12345



**typedef vs #define**

**#define** 是 C 指令，用于为各种数据类型定义别名，与 **typedef** 类似，但是它们有以下几点不同：

- **typedef** 仅限于为类型定义符号名称，**#define** 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。
- **typedef** 是由编译器执行解释的，**#define** 语句是由预编译器进行处理的。

下面是 #define 的最简单的用法：

```c
#include <stdio.h>
 
#define TRUE  1
#define FALSE 0
 
int main( )
{
   printf( "TRUE 的值: %d\n", TRUE);
   printf( "FALSE 的值: %d\n", FALSE);
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

> TRUE 的值: 1
> FALSE 的值: 0



# typedef void (*funcptr)(void)的含义

> fun a;
>
> //等价于void (*a)();这样声明起来就方便多了void(*a)();表示a是个指针，指向一个不带参数、返回值为空的函数

　　

> 定义一个函数指针类型。
> 比如你有三个函数：
>
> ```c
> void hello(void) { printf("你好!"); }
> void bye(void``) { printf("再见！"); }
> void ok(void) { printf("好的！"); }
> 
> typdef void (*funcptr)(void);
> ```
>
>  这样就构造了一个通用的函数
> 你用的时候可以这样：
>
> ```c
> void speak(int id)
> {
>    funcptr words[3] = {&hello, &bye, &ok};
>    funcptr fun = words[id];
>    (*fun)();
> }
> ```
>
> 这样的话，如果speak(0)就会显示“你好！”
> speak(1)就会显示“再见！”
> speak(2)就会显示“好的！”
>
>  用于处理参数和返回值的形式都一样，但是功能不确定的一组函数，可以使用函数指针。
> 比如算术运算符，加、减、乘、除，都可以用``typedef` `int` `(*calc)(``int``,``int``)代表，等等





# 4、Void使用

**void的作用**：

- 1.对函数返回的限定，这种情况我们比较常见。 

- 2.对函数参数的限定，这种情况也是比较常见的。

  一般我们常见的就是这两种情况：

  - 当函数不需要返回值值时，必须使用void限定，这就是我们所说的第一种情况。例如：void func（int a,char *b）。
  - 当函数不允许接受参数时，必须使用void限定，这就是我们所说的第二种情况。例如：int func(void)。

- void指针的使用规则：
  1.void指针可以***指向任意类型的数据***，就是说可以用任意类型的指针对void指针对void指针赋值。例如：

  > int *a；   
  >
  >void *p；   
  >
  >p=a；  
  >
  >如果要将void指针p赋给其他类型的指针，则需要强制类型转换，就本例而言：a=（int *）p。在内存的分配中我们可以见到void指针使用：内存分配函数malloc函数返回的指针就是void *型，用户在使用这个指针的时候，要进行强制类型转换，也就是显式说明该指针指向的内存中是存放的什么类型的数据（int *)malloc(1024)表示强制规定malloc返回的void*指针指向的内存中存放的是一个个的int型数据。 

  

# 5、Include<>和Include""区别
- #include< >
    　　#include< > 引用的是编译器的类库路径里面的头文件。
    　　假如你编译器定义的自带头文件引用在 C:\Keil\c51\INC\ 下面，则 #include<stdio.h> 引用的就是 C:\Keil\c51\INC\stdio.h 这个头文件，不管你的项目在什么目录里， C:\Keil\c51\INC\stdio.h 这个路径就定下来了，一般是引用自带的一些头文件，如： stdio.h、conio.h、string.h、stdlib.h 等等。
- #include< >
    　　#include" " 引用的是你程序目录的相对路径中的头文件。
    　　假如你的项目目录是在 D:\Projects\tmp\ ，则 #include"my.h" 引用的就是 D:\Projects\tmp\my.h 这个头文件，一般是用来引用自己写的一些头文件。如果使用 #include" " ，它是会先在你项目的当前目录查找是否有对应头文件，如果没有，它还是会在对应的引用目录里面查找对应的头文件。例如，使用 #include "stdio.h" 如果在你项目目录里面，没有 stdio.h 这个头文件，它还是会定位到 C:\Keil\c51\INC\stdio.h 这个头文件的。

# 6、C语言指针变量作为函数参数

指针变量这个范围就大了，包括普通的指针变量，也包括数组普通变量，也包括函数指针变量。

我们以`pthread_create`这个函数入参为例子：

```c
pthread_create(pthread_t *th, const pthread_attr_t *attr, void *(* func)(void *), void *arg);

```

其中参数`void *(* func)(void *),`表示一个函数指针，输入一个任务指针类型的参数，返回一个任意指针的类型。

> void* 表示任务指针类型



# 7、指向指针的指针

指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。

一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针：

```
int **var;
```

当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符，如下面实例所示：

```c
#include <stdio.h>
 
int main ()
{
   int  var;
   int  *ptr;
   int  **pptr;

   var = 3000;

   /* 获取 var 的地址 */
   ptr = &var;

   /* 使用运算符 & 获取 ptr 的地址 */
   pptr = &ptr;

   /* 使用 pptr 获取值 */
   printf("Value of var = %d\n", var );
   printf("Value available at *ptr = %d\n", *ptr );
   printf("Value available at **pptr = %d\n", **pptr);

   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```c
Value of var = 3000
Value available at *ptr = 3000
Value available at **pptr = 3000
```

# 8、C语言位模式是什么？

> 位段(bit-field)是以百位为单位来定义结构度体(或联合体)中的成员变量所占的空间。含有位段的结构体(联合体)称为位段结构。采用位段结构既能够节省空间，又方便问于操作。
> 位段的定义格式为:
> type [var]: digits
> 其中type只能为int，unsigned int，signed int三种类型(int型能不答能表示负数视编译器而定，比版如VC中int就默认是signed int，能够表示负数)。位段名称var是可选参数权，即可以省略。digits表示该位段所占的二进制位数。 

```c
#include<stdio.h>
struct mybitfields
{
	unsigned short a:4;
	unsigned short b:5;
	unsigned short c:7;	
}test;
 
int main()
{
	int i;
	test.a=2;
	test.b=3;
	test.c=0;
	i=*((short *) &test);
	printf("i=%d\n",i);
	printf("sizeof (short)= %d\n",sizeof(short));
	return 0;
}
```

```

```

> a占4个bit、b占5个bit、c占7个bit，总共16bit，大小和short的一样大！执行完下面的三条语句之后:
>
> 1. test.a=2;
> 2. test.b=3;
> 3. test.c=0;
>
> 内存分布（小端模式）：
>
> 0100 1100 0000 0000
>
> >  https://blog.csdn.net/liming0931/article/details/7721390 



# 9、柔性数组成员

> 柔性数组(flexible array member)也叫伸缩性数组成员，这种结构产生与对动态结构体的去求。在日常编程中，有时需要在结构体中存放一个长度是动态的字符串(也可能是其他数据类型)，一般的做法，实在结构体中定义一个指针成员，这个指针成员指向该字符串所在的动态内存空间。 

- 不完整类型

 不完整类型是一种**缺乏足够的信息**去描述一个完整对象的类型，还是以数组的定义/声明为例子。

```c++
// 一个为知长度的数组属于不完整类型
// 这个语句属于声明语句，不是定义语句
extern int a[];

// 这样的语句是错误的, extern关键字不能去掉
// int a[]

// 不完整类型的数组需要补充完整才能使用
// 下面的语句是声明语句（定义+初始化）
int a[] = {10, 20};
```

- 结构体
  -  不管结构体的实例是什么，访问其成员就是实例的地址加上成员偏移量。这个偏移量是编译器hard code的，跟内存对齐等因素有关。 

- 柔性数组

  ```c
  #include<cstring>
  #include<cstdlib>
  #include<cstdio>
  
  struct Test{
      int a;
      char *p;
  
      void set_str(const char *str){
          int len = std::strlen(str);
          if(len <=0)
              return;
  
          p = (char*)std::malloc((len+1)*sizeof(char));
          std::strcpy(p, str);
          p[len] = '\0';
      }
  };
  
  int main(){
      const char copy_str[] = "Hello World";
  
      Test t;
      t.set_str(copy_str);
      printf("Content:\n");
      printf("t.p:\t%s\n", t.p);
      
      printf("Address:\n");
      printf("t.p\t %p\n", t.p);
      printf("&t.p\t %p\n", &(t.p));
  }
  ```

  

  

- C99标准的定义如下

```c
struct flexible_t{
    int a;
    double b;
    char c[]; // 不只是char类型，其他类型同样也是可以
}
```

>  由于声明内存连续性的关系，柔性数组成员必须定义在结构体的最后一个，并且不能是唯一的成员。
> 我们再来看一看整个结构体(包含数组内存的分布情况)