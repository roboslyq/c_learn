# 1、this file does not belong to any project target, code insight features might not work
> 1、最直观的新建文件的文本编辑页面上方有： 
  This file does not belong to any project target, code insight features might not work properly 
  警告提示。 
  2、左边目录树中，新建文件夹和其中的新建文件都是灰色的。 
  3、而src文件夹和其中的文件都是彩色的。
  原因可能就是没有关联新建的文件夹。
  解决方案： 
  右键点击你新建的文件夹，选择Mark Directotry as，然后选择Project Sources and Headers： 

# 2、编译失败   undefined reference to `max'

修改CMakeLists.txt

```properties
#头文件引用路径：
include_directories(function pthread)

#如果有子CMakeFile文件
#add_subdirectory(function)

#将function/function.c pthread/thread.c组合到变量SOURCE_TMP
set(SOURCE_TMP function/function.c pthread/thread.c)

#控制多个可执行文件，后面${SOURCE_TMP}表示当前main.c中会引入这些文件
add_executable(main main.c ${SOURCE_TMP})
```



# 3、TypeDef使用



C 语言提供了 **typedef** 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 **BYTE**：

```c
typedef unsigned char BYTE;
```

在这个类型定义之后，标识符 BYTE 可作为类型 **unsigned char** 的缩写，例如：

```c
BYTE  b1, b2;
```

按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写，但您也可以使用小写字母，如下：

```c
typedef unsigned char byte;
```

您也可以使用 **typedef** 来为用户自定义的数据类型取一个新的名字。例如，您可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量，如下：

```c
#include <stdio.h>
#include <string.h>
 
typedef struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} Book;
 
int main( )
{
   Book book;
 
   strcpy( book.title, "C 教程");
   strcpy( book.author, "Runoob"); 
   strcpy( book.subject, "编程语言");
   book.book_id = 12345;
 
   printf( "书标题 : %s\n", book.title);
   printf( "书作者 : %s\n", book.author);
   printf( "书类目 : %s\n", book.subject);
   printf( "书 ID : %d\n", book.book_id);
 
   return 0;
}
```



当上面的代码被编译和执行时，它会产生下列结果：

> 书标题 : C 教程
> 书作者 : Runoob
> 书类目 : 编程语言
> 书 ID : 12345



**typedef vs #define**

**#define** 是 C 指令，用于为各种数据类型定义别名，与 **typedef** 类似，但是它们有以下几点不同：

- **typedef** 仅限于为类型定义符号名称，**#define** 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。
- **typedef** 是由编译器执行解释的，**#define** 语句是由预编译器进行处理的。

下面是 #define 的最简单的用法：

```c
#include <stdio.h>
 
#define TRUE  1
#define FALSE 0
 
int main( )
{
   printf( "TRUE 的值: %d\n", TRUE);
   printf( "FALSE 的值: %d\n", FALSE);
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

> TRUE 的值: 1
> FALSE 的值: 0



# typedef void (*funcptr)(void)的含义

> fun a;
>
> //等价于void (*a)();这样声明起来就方便多了void(*a)();表示a是个指针，指向一个不带参数、返回值为空的函数

　　

> 定义一个函数指针类型。
> 比如你有三个函数：
>
> ```c
> void hello(void) { printf("你好!"); }
> void bye(void``) { printf("再见！"); }
> void ok(void) { printf("好的！"); }
> 
> typdef void (*funcptr)(void);
> ```
>
>  这样就构造了一个通用的函数
> 你用的时候可以这样：
>
> ```c
> void speak(int id)
> {
>    funcptr words[3] = {&hello, &bye, &ok};
>    funcptr fun = words[id];
>    (*fun)();
> }
> ```
>
> 这样的话，如果speak(0)就会显示“你好！”
> speak(1)就会显示“再见！”
> speak(2)就会显示“好的！”
>
>  用于处理参数和返回值的形式都一样，但是功能不确定的一组函数，可以使用函数指针。
> 比如算术运算符，加、减、乘、除，都可以用``typedef` `int` `(*calc)(``int``,``int``)代表，等等





# 4、Void使用

**void的作用**：

- 1.对函数返回的限定，这种情况我们比较常见。 

- 2.对函数参数的限定，这种情况也是比较常见的。

  一般我们常见的就是这两种情况：

  - 当函数不需要返回值值时，必须使用void限定，这就是我们所说的第一种情况。例如：void func（int a,char *b）。
  - 当函数不允许接受参数时，必须使用void限定，这就是我们所说的第二种情况。例如：int func(void)。

- void指针的使用规则：
  1.void指针可以***指向任意类型的数据***，就是说可以用任意类型的指针对void指针对void指针赋值。例如：

  > int *a；   
  >
  >void *p；   
  >
  >p=a；  
  >
  >如果要将void指针p赋给其他类型的指针，则需要强制类型转换，就本例而言：a=（int *）p。在内存的分配中我们可以见到void指针使用：内存分配函数malloc函数返回的指针就是void *型，用户在使用这个指针的时候，要进行强制类型转换，也就是显式说明该指针指向的内存中是存放的什么类型的数据（int *)malloc(1024)表示强制规定malloc返回的void*指针指向的内存中存放的是一个个的int型数据。 

  

# 5、Include<>和Include""区别
- #include< >
    　　#include< > 引用的是编译器的类库路径里面的头文件。
    　　假如你编译器定义的自带头文件引用在 C:\Keil\c51\INC\ 下面，则 #include<stdio.h> 引用的就是 C:\Keil\c51\INC\stdio.h 这个头文件，不管你的项目在什么目录里， C:\Keil\c51\INC\stdio.h 这个路径就定下来了，一般是引用自带的一些头文件，如： stdio.h、conio.h、string.h、stdlib.h 等等。
- #include< >
    　　#include" " 引用的是你程序目录的相对路径中的头文件。
    　　假如你的项目目录是在 D:\Projects\tmp\ ，则 #include"my.h" 引用的就是 D:\Projects\tmp\my.h 这个头文件，一般是用来引用自己写的一些头文件。如果使用 #include" " ，它是会先在你项目的当前目录查找是否有对应头文件，如果没有，它还是会在对应的引用目录里面查找对应的头文件。例如，使用 #include "stdio.h" 如果在你项目目录里面，没有 stdio.h 这个头文件，它还是会定位到 C:\Keil\c51\INC\stdio.h 这个头文件的。

# 6、C语言指针变量作为函数参数

指针变量这个范围就大了，包括普通的指针变量，也包括数组普通变量，也包括函数指针变量。

我们以`pthread_create`这个函数入参为例子：

```c
pthread_create(pthread_t *th, const pthread_attr_t *attr, void *(* func)(void *), void *arg);

```

其中参数`void *(* func)(void *),`表示一个函数指针，输入一个任务指针类型的参数，返回一个任意指针的类型。

> void* 表示任务指针类型



# 7、指向指针的指针

指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。

一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针：

```
int **var;
```

当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符，如下面实例所示：

```c
#include <stdio.h>
 
int main ()
{
   int  var;
   int  *ptr;
   int  **pptr;

   var = 3000;

   /* 获取 var 的地址 */
   ptr = &var;

   /* 使用运算符 & 获取 ptr 的地址 */
   pptr = &ptr;

   /* 使用 pptr 获取值 */
   printf("Value of var = %d\n", var );
   printf("Value available at *ptr = %d\n", *ptr );
   printf("Value available at **pptr = %d\n", **pptr);

   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```c
Value of var = 3000
Value available at *ptr = 3000
Value available at **pptr = 3000
```